<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Prism 代码语法高亮</title>
    <link href="https://cdn.bootcss.com/prism/1.15.0/themes/prism.css" rel="stylesheet">

    <!-- import element CSS -->
    <link href="https://cdn.bootcss.com/element-ui/2.12.0/theme-chalk/index.css" rel="stylesheet">
    <!-- import github-markdown CSS -->
    <link href="https://cdn.bootcss.com/github-markdown-css/3.0.1/github-markdown.min.css" rel="stylesheet">
    <style>

    </style>

</head>

<body>


<div id="app">
    <p>[TOC]</p>
    <h1 id='介绍' class='header'>介绍</h1>
    <p>Vue是一个用于构建用户界面的渐进式框架，使用Vue时，你只需要关心数据，当你修改数据时，Vue会帮你渲染好视图，非常的方便</p>
    <h1 id='安装' class='header'>安装</h1>
    <p>在html中引入vue.js即可快速的使用</p>
    <p>在开发环境时可以引入：</p>
    <pre class="line-numbers"><code class="language-html">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
</code></pre>
    <p>在生产环境时可以引入：</p>
    <pre class="line-numbers"><code class="language-html">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
</code></pre><h1 id='快速入门' class='header'>快速入门</h1><pre class="line-numbers"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;

    &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;div id=&quot;app&quot;&gt;
        {{ message }}
    &lt;/div&gt;

&lt;/body&gt;

&lt;script&gt;
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
&lt;/script&gt;

&lt;/html&gt;
</code></pre><h2 id='文本内容替换' class='header'>文本内容替换</h2>
    <p>可以直接在html中使用<code>{{ message }}</code>来直接替换</p>
    <h2 id='绑定属性' class='header'>绑定属性</h2><pre class="line-numbers"><code class="language-html">&lt;span v-bind:title=&quot;message&quot;&gt;
  鼠标悬停几秒钟查看此处动态绑定的提示信息！
&lt;/span&gt;
</code></pre>
    <p>使用<code>v-bind:title=&quot;message&quot;</code>即可动态的绑定数据，而message则存在在data中</p>
    <p>你可以省略前缀<code>v-bind</code>，直接使用<code>:title=&quot;message&quot;</code></p>
    <h2 id='条件判断' class='header'>条件判断</h2>
    <p>可以使用<code>v-if=&quot;seen&quot;</code>来控制一个元素是否加载（狭义的显示）</p>
    <pre class="line-numbers"><code class="language-js">&lt;div id=&quot;app-3&quot;&gt;
  &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;
&lt;/div&gt;

var app3 = new Vue({
  el: '#app-3',
  data: {
    seen: true
  }
})
</code></pre><h2 id='循环' class='header'>循环</h2>
    <p>使用<code>v-for</code>来循环显示元素</p>
    <pre class="line-numbers"><code class="language-js">&lt;div id=&quot;app-4&quot;&gt;
</code></pre><h2 id='处理用户输入实现双向绑定' class='header'>处理用户输入实现双向绑定</h2>
    <p>使用<code>v-model</code>可以实现表单输入和应用状态之间的双向绑定</p>
    <pre class="line-numbers"><code class="language-js">&lt;div id=&quot;app-6&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;input v-model=&quot;message&quot;&gt;
&lt;/div&gt;

var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})
</code></pre><h2 id='构建组建' class='header'>构建组建</h2>
    <p>在Vue中，一个组件本质上时一个拥有预定于选项的一个Vue实例；</p>

    <p>使用注册的组件：</p>
    <pre class="line-numbers"><code class="language-html">&lt;ol&gt;

&lt;/ol&gt;
</code></pre>
    <p>注册一个复杂的组件：</p>
    <p>组件可以接受一个<code>prop</code>属性</p>


    <p>现在我们可以使用<code>v-bind</code>指令将代办事项传到循环输出的每个组件中：</p>
 <h1 id='Vue实例' class='header'>Vue实例</h1>
    <p>通过<code>new Vue()</code>来创建Vue实例</p>
    <pre class="line-numbers"><code class="language-js">var vm = new Vue({
  // 选项
	el: '#app',
  data: {
  },
	//钩子
	created: function () {
    // `this` 指向 vm 实例
    console.log('a is: ' + this.a)
  },
	// 在 `methods` 对象中定义方法
  methods: {
    greet: function (event) {
      // `this` 在方法里指向当前 Vue 实例
      alert('Hello ' + this.name + '!')
    }
  },
	//计算属性
	computed: {
    // 计算属性的 getter

  },
	//监听器
  watch: {
      // 如果 `question` 发生改变，这个question函数就会运行
      question: function (newQuestion, oldQuestion) {
          this.answer=newQuestion;
      }
    }
})
</code></pre><h1 id='Vue的生命周期' class='header'>Vue的生命周期</h1>
    <p><img src='/css/loading.gif' buff='/Users/yingjie.lu/Documents/note/.img/lifecycle.png'><img></p>
    <ol>
        <li>
            <p>new Vue()</p>
        </li>
        <li>
            <p>初始化（事件&amp;生命周期）</p>
            <p><strong>钩子：beforeCreate</strong></p>
        </li>
        <li>
            <p>初始化（注入&amp;校验）</p>
            <p><strong>钩子：created</strong></p>
        </li>
        <li>
            <p>进行模版解析</p>
            <p><strong>钩子：beforeMount</strong></p>
        </li>
        <li>
            <p>挂载dom元素</p>
            <p><strong>钩子：mounted</strong></p>
        </li>
        <li>
            <p>挂载完毕后开始数据data监听</p>
            <p>如果数据改变，则重新渲染更新</p>
            <p><strong>钩子：beforeUpdate</strong></p>
            <p><strong>钩子：updated</strong></p>
        </li>
        <li>
            <p>当调用vm.$destroy()函数时</p>
            <p><strong>钩子：beforeDestory</strong></p>
        </li>
        <li>
            <p>解除绑定（销毁子组件及事件监听器）</p>
        </li>
        <li>
            <p>销毁完毕</p>
            <p><strong>钩子：destroyed</strong></p>
        </li>
    </ol>
    <h1 id='模版语法' class='header'>模版语法</h1><h2 id='插值' class='header'>插值</h2><h3 id='文本' class='header'>文本</h3><pre class="line-numbers"><code class="language-html">&lt;span&gt;Message: {{ msg }}&lt;/span&gt;
</code></pre><h3 id='原始html' class='header'>原始html</h3>
    <p>将双大括号内的数据解释为html,只需要标记<code>v-html</code>即可</p>
    <pre class="line-numbers"><code class="language-html">&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;
</code></pre>
    <blockquote>
        <p>rawHtml为：</p>
        <pre class="line-numbers"><code class="language-js">data:{
	rawHtml:'&lt;span style=&quot;color:red&quot;&gt;this should be red.&lt;/span&gt;'
}
</code></pre>
        <p>}</p>
    </blockquote>
    <h3 id='特性' class='header'>特性</h3>
    <p>当不能作用在html标签上时，可以使用<code>v-bind</code>指令来解决</p>
    <pre class="line-numbers"><code class="language-html">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;
</code></pre>
    <p>如果<code>dynamicId</code>在data中改变了，那么div中的id属性也会动态的改变</p>
    <pre class="line-numbers"><code class="language-html">&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;
</code></pre>
    <p>如果 <code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled</code> 特性甚至不会被包含在渲染出来的 `` 元素中。</p>
    <h3 id='使用js表达式' class='header'>使用js表达式</h3>
    <p>vue支持在双大括号中计算js表达式：</p>
    <p>支持一下几种：</p>
    <pre class="line-numbers"><code class="language-js">{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

&lt;div v-bind:id=&quot;'list-' + id&quot;&gt;&lt;/div&gt;
</code></pre><h2 id='指令' class='header'>指令</h2>
    <p>指令是带有<code>v-</code>前缀的特殊属性，指令需要的值是单个js表达式（<code>v-for</code>指令除外）</p>
    <p>指令的职责是当表达式的值改变时，会动态的作用到dom中</p>
    <p>如：</p>
    <pre class="line-numbers"><code class="language-html">&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;
</code></pre>
    <blockquote>
        <p>这里可以根据表达式 <code>seen</code> 的值的真假来插入/移除<code>&lt;p&gt;</code>元素。</p>
    </blockquote>
    <h3 id='参数' class='header'>参数</h3>
    <p>一些指令能够接受一个参数，来更新html特性的属性，如：</p>
    <pre class="line-numbers"><code class="language-html">&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;
</code></pre>
    <blockquote>
        <p>这里href是参数，告知v-bind指令将该元素的href特性与表达式url的值绑定</p>
    </blockquote>
    <p><code>v-on</code>指令可以监听dom事件：</p>
    <pre class="line-numbers"><code class="language-html">&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;
</code></pre>
    <blockquote>
        <p>监听a标签的额点击事件</p>
    </blockquote>
    <h3 id='修饰符' class='header'>修饰符</h3>
    <p>修饰符<code>.</code>指明特殊后缀，用于之处一个指令应该以特殊方式绑定，例如<code>.preven</code>修饰符告诉<code>v-on</code>指令对于触发的事件调用<code>event.preventDefault()</code>方法</p>
    <pre class="line-numbers"><code class="language-html">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;
</code></pre><h2 id='缩写' class='header'>缩写</h2>
    <ul>
        <li>
            <p>v-bind缩写</p>
            <pre class="line-numbers"><code class="language-html">&lt;!-- 完整语法 --&gt;
&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;
</code></pre></li>
        <li>
            <p>v-on缩写</p>
            <pre class="line-numbers"><code class="language-html">&lt;!-- 完整语法 --&gt;
&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;
</code></pre></li>
    </ul>
    <h1 id='计算属性' class='header'>计算属性</h1>
    <p>如果在模版内部放太多的逻辑会让模版过重且难以维护，所以我们可以使用计算属性来解决，例如：</p>
    <pre class="line-numbers"><code class="language-js">&lt;div id=&quot;example&quot;&gt;
  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;
  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;
&lt;/div&gt;

var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的reversedMessage值可以直接在模版中引用
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
</code></pre>
    <p>计算属性中，如果data中的属性值改变，并且计算属性中使用到了，那么会触发计算属性重新计算，计算后会缓存计算结果，每次渲染模版时不会重新计算，而使用缓存值，这将大大提高性能</p>
    <blockquote>
        <p>在模版中直接使用js表达式，则每次重新渲染模版时都会进行重新的计算，而不会没有缓存值</p>
    </blockquote>
    <h1 id='监听器' class='header'>监听器</h1>
    <p>我们可以使用<code>watch</code>选项来提供一个更通用的方法来响应数据的变化，当需要在数据变化时执行一步或开销较大的操作时，这个方式是最有用的</p>
    <p>例如：</p>
    <pre class="line-numbers"><code class="language-js">&lt;div id=&quot;watch-example&quot;&gt;
  &lt;p&gt;
    Ask a yes/no question:
    &lt;input v-model=&quot;question&quot;&gt;
  &lt;/p&gt;
  &lt;p&gt;{{ answer }}&lt;/p&gt;
&lt;/div&gt;

var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'I cannot give you an answer until you ask a question!'
  },
  watch: {
    // 如果 `question` 发生改变，这个question函数就会运行
    question: function (newQuestion, oldQuestion) {
      	this.answer=newQuestion;
    }
  }
})
</code></pre><h1 id='Class与Style绑定' class='header'>Class与Style绑定</h1><h2 id='绑定HTML Class' class='header'>绑定HTML Class</h2><h3 id='对象语法' class='header'>对象语法</h3>
    <p>我们可以使用<code>v-bind:class</code>来更方便的动态切换class</p>
    <p>例如：</p>
    <pre class="line-numbers"><code class="language-html">&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;
</code></pre>
    <blockquote>
        <p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于数据属性 <code>isActive</code> 的值为true或false</p>
    </blockquote>
    <p>我们可以传入更多的属性来动态切换多个class</p>
    <pre class="line-numbers"><code class="language-js">&lt;div
  class=&quot;static&quot;
  v-bind:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;
&gt;&lt;/div&gt;

data: {
  isActive: true,
  hasError: false
}
</code></pre>
    <p>结果渲染为：</p>
    <pre class="line-numbers"><code class="language-html">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;
</code></pre>
    <blockquote>
        <p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新</p>
    </blockquote>
    <p>绑定的数据对象不必内联定义在模板里，例如：</p>
    <pre class="line-numbers"><code class="language-js">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;

data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
</code></pre><h3 id='数组语法' class='header'>数组语法</h3>
    <p>我们可以把一个数组传给<code>v-bind:class</code>,以应用一个 class 列表,例如：</p>
    <pre class="line-numbers"><code class="language-js">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;

data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
</code></pre>
    <p>我们也可以使用三元表达式来切换class</p>
    <pre class="line-numbers"><code class="language-html">&lt;div v-bind:class=&quot;[isActive ? activeClass : '', errorClass]&quot;&gt;&lt;/div&gt;
</code></pre><h2 id='绑定内联样式' class='header'>绑定内联样式</h2><h3 id='对象语法' class='header'>对象语法</h3>
    <p><code>v-bind:style</code>可以方便的修改标签的style属性</p>
    <pre class="line-numbers"><code class="language-js">&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;

data: {
  activeColor: 'red',
  fontSize: 30
}
</code></pre>
    <p>或者直接绑定到一个样式对象上，这会让模版更清晰</p>
    <pre class="line-numbers"><code class="language-js">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;

data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
</code></pre><h3 id='数组语法' class='header'>数组语法</h3>
    <p><code>v-bind:style</code>通过数组语法可以将多个样式对象应用到同一个元素上</p>
    <pre class="line-numbers"><code class="language-html">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;
</code></pre><h1 id='条件渲染' class='header'>条件渲染</h1><h2 id='v-if' class='header'>v-if</h2>
    <p>简单使用：</p>
    <pre class="line-numbers"><code class="language-html">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;
</code></pre>
    <p>在<code>&lt;template&gt;</code>元素上使用：</p>
    <pre class="line-numbers"><code class="language-html">&lt;template v-if=&quot;ok&quot;&gt;
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Paragraph 1&lt;/p&gt;
&lt;/template&gt;
</code></pre>
    <p>配合v-else使用：</p>
    <pre class="line-numbers"><code class="language-html">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;
&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;
</code></pre>
    <p>v-else-if使用：</p>
    <pre class="line-numbers"><code class="language-html">&lt;div v-if=&quot;type === 'A'&quot;&gt;A&lt;/div&gt;
&lt;div v-else-if=&quot;type === 'B'&quot;&gt;B&lt;/div&gt;
&lt;div v-else-if=&quot;type === 'C'&quot;&gt;C&lt;/div&gt;
&lt;div v-else&gt;Not A/B/C&lt;/div&gt;
</code></pre>
    <p>使用key管理可复用的元素</p>
    <p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染</p>
    <pre class="line-numbers"><code class="language-html">&lt;template v-if=&quot;loginType === 'username'&quot;&gt;
  &lt;label&gt;Username&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;
&lt;/template&gt;
&lt;template v-else&gt;
  &lt;label&gt;Email&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;
&lt;/template&gt;
</code></pre>
    <blockquote>
        <p>当你来回的切换v-if和v-else的元素时，因为你使用了key来缓存，那么vue不会反复的创建使用key来标识的标签对象，而是重复利用</p>
    </blockquote>
    <h2 id='v-show' class='header'>v-show</h2>
    <p><code>v-show</code>的用法和<code>v-if</code>相像，带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display</code>。</p>
    <pre class="line-numbers"><code class="language-html">&lt;h1 v-show=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;
</code></pre><h2 id='v-for' class='header'>v-for</h2><h3 id='简单循环渲染（数组）：' class='header'>简单循环渲染（数组）：</h3><pre class="line-numbers"><code class="language-js">&lt;ul&gt;
  &lt;li v-for=&quot;item in items&quot;&gt;
    {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;

data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
</code></pre><h3 id='循环渲染（对象）：' class='header'>循环渲染（对象）：</h3><pre class="line-numbers"><code class="language-js">&lt;ul&gt;
  &lt;li v-for=&quot;(value,index) in object&quot;&gt;
    {{ index }}.{{ value }}
  &lt;/li&gt;
&lt;/ul&gt;

data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
</code></pre>
    <blockquote>
        <p>渲染结果：</p>
        <ul>
            <li>0.How to do lists in Vue</li>
            <li>1.Jane Doe</li>
            <li>2.2016-04-10</li>
        </ul>
    </blockquote>
    <h3 id='数组更新检测' class='header'>数组更新检测</h3>
    <p>Vue将以下数组方法来更新数据：</p>
    <ul>
        <li><code>push()</code></li>
        <li><code>pop()</code></li>
        <li><code>shift()</code></li>
        <li><code>unshift()</code></li>
        <li><code>splice()</code></li>
        <li><code>sort()</code></li>
        <li><code>reverse()</code></li>
    </ul>
    <h1 id='事件处理' class='header'>事件处理</h1><h2 id='简单事件处理' class='header'>简单事件处理</h2>
    <p>可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p>
    <p>例如：</p>
    <pre class="line-numbers"><code class="language-js">&lt;button v-on:click=&quot;counter += 1&quot;&gt;Add&lt;/button&gt;

data: {
    counter: 0
  }
</code></pre><h2 id='指定事件处理方法' class='header'>指定事件处理方法</h2><pre class="line-numbers"><code class="language-js">&lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;

var example2 = new Vue({
  el: '#example-2',
  // 在 `methods` 对象中定义方法
  methods: {
    greet: function (event) {
      // `this` 在方法里指向当前 Vue 实例
      alert('Hello ' + this.name + '!')
      // `event` 是原生 DOM 事件
      if (event) {
        alert(event.target.tagName)
      }
    }
  }
})

// 也可以用 JavaScript 直接调用方法
example2.greet() // =&gt; 'Hello Vue.js!'
</code></pre><h2 id='事件方法传递参数' class='header'>事件方法传递参数</h2><pre class="line-numbers"><code class="language-js">&lt;div id=&quot;example-3&quot;&gt;
  &lt;button v-on:click=&quot;say('hi')&quot;&gt;Say hi&lt;/button&gt;
  &lt;button v-on:click=&quot;say('what')&quot;&gt;Say what&lt;/button&gt;
&lt;/div&gt;

new Vue({
  el: '#example-3',
  methods: {
    say: function (message) {
      alert(message)
    }
  }
})
</code></pre><h2 id='事件修饰符' class='header'>事件修饰符</h2>
    <p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求</p>
    <p>在Vue中可以使用<code>v-on</code>的事件修饰符来方便快速的完成：</p>
    <ul>
        <li><code>.stop</code></li>
        <li><code>.prevent</code></li>
        <li><code>.capture</code></li>
        <li><code>.self</code></li>
        <li><code>.once</code></li>
        <li><code>.passive</code></li>
    </ul>
    <pre class="line-numbers"><code class="language-html">&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre><h2 id='按键修饰符' class='header'>按键修饰符</h2>
    <p>Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符，例如：</p>
    <pre class="line-numbers"><code class="language-html">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;
&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;
</code></pre>
    <p>按键码的别名：</p>
    <ul>
        <li><code>.enter</code></li>
        <li><code>.tab</code></li>
        <li><code>.delete</code> (捕获“删除”和“退格”键)</li>
        <li><code>.esc</code></li>
        <li><code>.space</code></li>
        <li><code>.up</code></li>
        <li><code>.down</code></li>
        <li><code>.left</code></li>
        <li><code>.right</code></li>
    </ul>
    <p>我们可以使用按键码别名或者是使用keyCodes</p>
    <p>我们还可以通过全局<code>config.keyCodes</code> 对象自定义按键修饰符别名：</p>
    <pre class="line-numbers"><code class="language-js">// 可以使用 `v-on:keyup.f1`
Vue.config.keyCodes.f1 = 112
</code></pre><h2 id='系统修饰键' class='header'>系统修饰键</h2><h3 id='ctrl,alt,shift,command键' class='header'>ctrl,alt,shift,command键</h3>
    <p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
    <ul>
        <li><code>.ctrl</code></li>
        <li><code>.alt</code></li>
        <li><code>.shift</code></li>
        <li><code>.meta</code></li>
    </ul>
    <blockquote>
        <p>注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。</p>
    </blockquote>
    <p>例如：</p>
    <pre class="line-numbers"><code class="language-html">&lt;!-- Alt + C --&gt;
&lt;input @keyup.alt.67=&quot;clear&quot;&gt;

&lt;!-- Ctrl + Click --&gt;
&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;
</code></pre>
    <blockquote>
        <p>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。如果你想要这样的行为，请为 <code>ctrl</code> 换用 <code>keyCode</code>：<code>keyup.17</code>。</p>
    </blockquote>
    <h3 id='.exact 修饰符' class='header'>.exact 修饰符</h3>
    <p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
    <p>示例：</p>
    <pre class="line-numbers"><code class="language-html">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;
&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;
&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;
&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
</code></pre><h3 id='鼠标修饰符' class='header'>鼠标修饰符</h3>
    <ul>
        <li><code>.left</code></li>
        <li><code>.right</code></li>
        <li><code>.middle</code></li>
    </ul>
    <h1 id='表单输入绑定' class='header'>表单输入绑定</h1>
    <p>使用<code>v-model</code>指令可以在<code>&lt;input&gt;,&lt;textarea&gt;,&lt;select&gt;</code>元素中创建双向数据绑定，它会根据控件类型自动选取正确的方法来更新元素</p>
    <p><code>v-model</code> 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
    <ul>
        <li>text 和 textarea 元素使用 <code>value</code> 属性和 <code>input</code> 事件；</li>
        <li>checkbox 和 radio 使用 <code>checked</code> 属性和 <code>change</code> 事件；</li>
        <li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
    </ul>
    <h2 id='文本' class='header'>文本</h2><pre class="line-numbers"><code class="language-html">&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;
&lt;p&gt;Message is: {{ message }}&lt;/p&gt;
</code></pre><h2 id='多行文本' class='header'>多行文本</h2><pre class="line-numbers"><code class="language-html">&lt;p style=&quot;white-space: pre-line;&quot;&gt;{{ message }}&lt;/p&gt;
&lt;br&gt;
&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;
</code></pre><h2 id='复选框' class='header'>复选框</h2><pre class="line-numbers"><code class="language-html">&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
&lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt;
</code></pre><h2 id='单选按钮' class='header'>单选按钮</h2><pre class="line-numbers"><code class="language-html">&lt;div id=&quot;example-4&quot;&gt;
  &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;
  &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;
  &lt;br&gt;
  &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;
  &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;
  &lt;br&gt;
  &lt;span&gt;Picked: {{ picked }}&lt;/span&gt;
&lt;/div&gt;

new Vue({
  el: '#example-4',
  data: {
    picked: ''
  }
})
</code></pre><h2 id='选择框' class='header'>选择框</h2><pre class="line-numbers"><code class="language-html">&lt;div id=&quot;example-5&quot;&gt;
  &lt;select v-model=&quot;selected&quot;&gt;
    &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;
    &lt;option&gt;A&lt;/option&gt;
    &lt;option&gt;B&lt;/option&gt;
    &lt;option&gt;C&lt;/option&gt;
  &lt;/select&gt;
  &lt;span&gt;Selected: {{ selected }}&lt;/span&gt;
&lt;/div&gt;

new Vue({
  el: '#example-6',
  data: {
    selected: []
  }
})
</code></pre><h2 id='修饰符' class='header'>修饰符</h2><h3 id='.lazy' class='header'>.lazy</h3><h3 id='.number' class='header'>.number</h3><h3 id='.trim' class='header'>.trim</h3>
    <p>自动过滤用户输入的首尾空白字符</p>
    <pre class="line-numbers"><code class="language-html">&lt;input v-model.trim=&quot;msg&quot;&gt;
</code></pre><h1 id='组件基础' class='header'>组件基础</h1>
    <p>https://cn.vuejs.org/v2/guide/components.html</p>
    <h1 id='参考文档' class='header'>参考文档</h1>
    <p><a href="https://cn.vuejs.org/v2/guide/">官方文档</a></p>


</div>

<script src="https://cdn.bootcss.com/prism/1.15.0/prism.js"></script>
<script src="https://cdn.bootcss.com/prism/1.15.0/components/prism-java.js"></script>

<script src="https://cdn.bootcss.com/vue/2.6.10/vue.common.dev.js"></script><!--开发的时候使用生产模式-->
<!--axios.js-->
<script src="https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js"></script>
<!--element.js-->
<script src="https://cdn.bootcss.com/element-ui/2.12.0/index.js"></script>


<script>
    var vue=new Vue({
        el: '#app',
        data: {
        },
    })
</script>

</body>

</html>
