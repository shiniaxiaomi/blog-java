<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<p>[TOC]</p>
<h1>简介</h1>
<p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</p>
<p>使用 Express 可以快速地搭建一个完整功能的网站。</p>
<p>Express 框架核心特性：</p>
<ul>
    <li>可以设置中间件来响应 HTTP 请求。</li>
    <li>定义了路由表用于执行不同的 HTTP 请求动作。</li>
    <li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>
</ul>
<h1>安装</h1>
<p>安装express</p>
<p><code>cnpm install express --save</code></p>
<h2>hello world</h2>
<ul>
    <li>
        <p>创建一个demo.js</p>
        <pre><code class="language-js">var express = require('express');//导入express模块
var app = express();//获取app对象

//当'/'请求时的回调(request 和 response 对象来处理请求和响应的数据)
app.get('/', function (req, res) {
   res.send('Hello World');
})

//启动server并监听再8081端口
var server = app.listen(8081, function () {
  var host = server.address().address;
  var port = server.address().port;
  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port);
})
</code></pre>
    </li>
    <li>
        <p>执行demo.js</p>
        <p><code>node demo.js</code></p>
    </li>
    <li>
        <p>访问网址http://localhost:8081</p>
    </li>
</ul>
<h1>路由</h1>
<p>分别对应不同的url请求</p>
<ul>
    <li>
        <p>访问主页</p>
        <p><code>app.get('/', function (req, res){})</code></p>
    </li>
    <li>
        <p>普通的url请求</p>
        <p><code>app.get('/del_user', function (req, res) {})</code></p>
    </li>
    <li>
        <p>使用正则来匹配url请求</p>
        <p><code>app.get('/ab*cd', function(req, res) {})</code></p>
    </li>
</ul>
<h1>静态资源</h1>
<p>Express 提供了内置的中间件 express.static 来设置静态文件</p>
<ul>
    <li>
        <p>设置public目录为静态资源文件路径</p>
        <pre><code class="language-js">var express = require('express');
var app = express();
app.use('/public', express.static('public'));
</code></pre>
    </li>
    <li>
        <p>在public目录下放<code>logo.png</code>图片并访问</p>
        <p><code>http://localhost:8081/public/logo.png</code>即可看到图片</p>
    </li>
</ul>
<h1><a href="http://www.expressjs.com.cn/4x/api.html">API</a></h1>
<h2>express全局方法</h2>
<h3>express.json([options])</h3>
<p>设置express框架中处理json的一些配置</p>
<blockquote>
    <p>此中间件在Express v4.16.0及更高版本中可用。</p>
</blockquote>
<p>这是Express中的内置中间件功能。该功能会查看<code>Content-Type</code>标头与<code>type</code>选项匹配的请求, 解析后在<code>request</code>对象上填充包含已解析数据的新对象<code>req.body</code></p>
<p>option对象属性</p>
<ul>
    <li>
        <p>inflate</p>
        <p>类型: 布尔 (默认为true)</p>
        <blockquote>
            <p>启动或禁止压缩json文本</p>
        </blockquote>
    </li>
    <li>
        <p>limit</p>
        <p>类型: String (默认为&quot;100kb&quot;)</p>
        <blockquote>
            <p>控制最大请求体大小</p>
        </blockquote>
    </li>
    <li>
        <p>type</p>
        <p>类型: String (默认为&quot;application/json&quot;)</p>
        <blockquote>
            <p>用于确认需要解析的类型</p>
        </blockquote>
    </li>
</ul>
<h3>express.static(root,[options])</h3>
<p>设置应用的静态资源路径</p>
<blockquote>
    <p>为获取最佳的结果,推荐使用反向代理缓存来提高服务静态资源的性能</p>
</blockquote>
<p>root参数</p>
<ul>
    <li>指定静态资源的根目录, 其通过req.url和root组合来确定提供的文件, 如果没有找到,则会调用next() 继续递归的寻找资源文件</li>
</ul>
<p>options参数</p>
<ul>
    <li>
        <p>maxAge</p>
        <p>类型: 数值或字符串 (默认为0)</p>
        <blockquote>
            <p>设置静态资源的缓存时间</p>
        </blockquote>
    </li>
    <li>
        <p>示例</p>
        <pre><code class="language-js">var options = {
  dotfiles: 'ignore',
  etag: false,
  extensions: ['htm', 'html'],
  index: false,
  maxAge: '1d', //缓存时间设置为1天
  redirect: false,
  setHeaders: function (res, path, stat) {
    res.set('x-timestamp', Date.now())
  }
}
</code></pre>
        <p>简单使用</p>
        <pre><code class="language-js">app.use(&quot;&quot;, express.static(&quot;/css&quot;));
app.use(&quot;&quot;, express.static(&quot;/js&quot;));
</code></pre>
    </li>
</ul>
<h2>express对象</h2>
<h3>express对象属性</h3>
<h4>app.locals</h4>
<p>该属性为此次应用程序中的全局变量,该变量在程序的整个生命周期中保持不变</p>
<p>设置一些全局变量</p>
<pre><code class="language-js">app.locals.title = 'My App';
app.locals.strftime = require('strftime');
app.locals.email = 'me@myapp.com';
</code></pre>
<h3>express对象方法</h3>
<h4>app.all(path,callback,[callback...])</h4>
<p>此方法是用于匹配所有的http请求(包括了get和post等类型的请求), 该方法在http请求匹配时会被最前匹配,匹配之后如果其他匹配模式也符合,则继续回调</p>
<p>path参数</p>
<ul>
    <li>用于匹配匹配url的正则表达式</li>
</ul>
<p>callback参数</p>
<ul>
    <li>
        <p>回调函数</p>
        <pre><code class="language-js">app.all('/secret', function (req, res, next) {
    console.log('Accessing the secret section ...')
  	next() // 接着下一个匹配的http处理器
})
</code></pre>
    </li>
    <li>
        <p>可以填写多个回调函数</p>
        <pre><code class="language-js">app.all('*', requireAuthentication, loadUser);
//如同
app.all('*', requireAuthentication);
app.all('*', loadUser);
</code></pre>
    </li>
</ul>
<h4>其他http请求处理函数</h4>
<ul>
    <li>app.get(path,callback [,callback ...])</li>
    <li>app.post(path,callback [,callback ...])</li>
    <li>app.delete(path,callback,[callback...])</li>
    <li>app.put(path,callback,[callback...])</li>
</ul>
<p>用法都和上面的<code>app.all(path,callback,[callback...])</code>相同</p>
<h4>app.listen([port [，host [，backlog]]] [，callback])</h4>
<p>绑定并监听指定主机和端口上的连接</p>
<pre><code class="language-js">var server = app.listen(80, function() {
    console.log(&quot;应用实例启动成功!&quot;);
});
</code></pre>
<h4>app.param（[name]，callback）</h4>
<p>指定当有http中带有name中的参数时,则会触发该回调函数</p>
<blockquote>
    <p>如果name是数组,则callback则按声名的顺序为其声名的每个参数注册触发器</p>
</blockquote>
<pre><code class="language-js">app.param('id', function (req, res, next, id) {
  console.log('CALLED ONLY ONCE',id);
  next();  // 接着下一个匹配的http处理器
});
app.get('/user/:id', function (req, res, next) {
  console.log('although this matches');
  next();
});
</code></pre>
<blockquote>
    <p>当发送请求<code>/user/19</code>时,上面两个回调函数都会被调用,并且都能够回去到id的值, 而且<code>param</code>对应的回调会先于其他回调函数</p>
</blockquote>
<h4>app.render(view, [locals], callback)</h4>
<p>通过在callback中渲染参数,并返回视图</p>
<pre><code class="language-js">app.render('email', { name: 'Tobi' }, function(err, html){
  // ...
});
</code></pre>
<h4>app.use（[path，] callback [，callback ...]）</h4>
<p>在指定的路径中安装指定的中间件函数,当请求的路径和请求的url匹配时,就会执行中间件函数</p>
<blockquote>
    <p>默认的path为''/'',因此每个请求都会执行该回调函数</p>
</blockquote>
<pre><code class="language-js">app.use(function (req, res, next) {
  console.log('Time: %d', Date.now());
  next();
});
</code></pre>
<p>中间件的执行顺序很重要,具体参考API文档</p>
<h2>request对象(请求)</h2>
<h3>req对象的参数</h3>
<h4>req.app</h4>
<p>此属性包含了express创建出来的实例,可以获取到之前在app中set的一些全局变量</p>
<pre><code class="language-js">req.app.get('views')
</code></pre>
<h4>req.body</h4>
<p>包含请求正文中提交的键值对数据,默认情况下,当解析url请求的数据参数后,会将解析完的内容填充到req.body中</p>
<blockquote>
    <p>解析http的参数需要安装对应的中间件才可以正常的使用</p>
</blockquote>
<pre><code class="language-js">var app = require('express')();
var bodyParser = require('body-parser');
var multer = require('multer'); // v1.0.5
var upload = multer(); // for parsing multipart/form-data

app.use(bodyParser.json()); // for parsing application/json
app.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded

app.post('/profile', upload.array(), function (req, res, next) {
  console.log(req.body);
  res.json(req.body);
});
</code></pre>
<h4>req.cookies</h4>
<p>使用<code>cookie-parser</code>中间件时,此属性时包含请求发送的cookie的对象; 如果请求不包含cookie,则默认为{}</p>
<pre><code class="language-js">// Cookie: name=tj
req.cookies.name
// =&gt; &quot;tj&quot;
</code></pre>
<h4>req.hostname</h4>
<p>获取http的host主机名</p>
<pre><code class="language-js">// Host: &quot;example.com:3000&quot;
req.hostname
// =&gt; &quot;example.com&quot;
</code></pre>
<h4>req.ip</h4>
<p>获取远程的ip</p>
<pre><code class="language-javascript">req.ip
// =&gt; &quot;127.0.0.1&quot;
</code></pre>
<h4>req.method</h4>
<p>获取http请求的方法类型(post,get...)</p>
<h4>req.params</h4>
<p>此属性是一个对象,包好了url请求中的参数</p>
<blockquote>
    <p>如果url的请求是<code>/user/:name</code>,则</p>
    <pre><code class="language-js">// GET /user/tj
req.params.name
// =&gt; &quot;tj&quot;
</code></pre>
</blockquote>
<h4>req.path</h4>
<p>获取url的请求,不包含域名和参数</p>
<pre><code class="language-javascript">// example.com/users?sort=desc
req.path
// =&gt; &quot;/users&quot;
</code></pre>
<h4>req.query</h4>
<p>此属性是一个对象,包含url中那个查询字符串参数的属性; 如果没有查询字符串,则为空对象{}</p>
<pre><code class="language-javascript">// GET /search?q=tobi+ferret
req.query.q
// =&gt; &quot;tobi ferret&quot;
</code></pre>
<h4>req.xhr</h4>
<p>一个布尔属性,如果是true则表示请求的<code>X-Requested-With</code>头字段是“XMLHttpRequest”</p>
<pre><code class="language-javascript">req.xhr
// =&gt; true
</code></pre>
<h3>req对象的方法</h3>
<h4>req.get(field)</h4>
<p>获取http的header中的字段</p>
<pre><code class="language-javascript">req.get('Content-Type');
// =&gt; &quot;text/plain&quot;
</code></pre>
<h2>response对象(响应)</h2>
<h3>res对象属性</h3>
<h4>res.app</h4>
<p>用法和req.app一样</p>
<h3>res对象方法</h3>
<h4>res.append(field [, value])</h4>
<p>在http的返回的消息头中添加一些字段,如果没有该字段,则会被创建; 这个value可以是String也可以是一个array</p>
<pre><code class="language-js">res.append('Link', ['&lt;http://localhost/&gt;', '&lt;http://localhost:3000/&gt;']);
res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
res.append('Warning', '199 Miscellaneous warning');
</code></pre>
<h4>res.cookie(name, value [, options])</h4>
<p>设置cookies; value可以是String也可以是JSON</p>
<p>options参数</p>
<ul>
    <li>
        <p>expires</p>
        <p>类型是Date,设置cookie的过期日期</p>
    </li>
    <li>
        <p>maxAge</p>
        <p>类型是Number,设置cookie从现在开始后多少毫秒钟过期</p>
    </li>
    <li>
        <p>path</p>
        <p>类型是String, 设置cookie对应的url路径</p>
    </li>
</ul>
<pre><code class="language-js">res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
</code></pre>
<h4>res.clearCookie(name [, options])</h4>
<p>根据name来清除对应的cookie</p>
<pre><code class="language-javascript">res.clearCookie('name', { path: '/admin' }); //可以设置option来指定path来对应指定的cookie
</code></pre>
<h4>res.download(path [, filename] [, options] [, fn])</h4>
<p>可以指定path对应指定的文件,然后当访问这个url的时候,会把文件返回给用户</p>
<blockquote>
    <p>该方法使用的res.sendFile()来实现的,默认是去指定的资源路径下找文件</p>
</blockquote>
<pre><code class="language-javascript">res.download('/report-12345.pdf');
res.download('/report-12345.pdf', 'report.pdf');//可以指定文件名称
res.download('/report-12345.pdf', 'report.pdf',function(err){});//可以指定回调函数
</code></pre>
<h4>res.end([data] [, encoding])</h4>
<p>直接结束response进程</p>
<pre><code class="language-javascript">res.end();
res.status(404).end();
</code></pre>
<h4>res.get(field)</h4>
<p>通过指定对应的字段来获取response的header中的数据</p>
<pre><code class="language-javascript">res.get('Content-Type');
// =&gt; &quot;text/plain&quot;
</code></pre>
<h4>res.json([body])</h4>
<p>发送一个JSON的response,数据就直接是一个json格式的</p>
<pre><code class="language-javascript">res.json(null);
res.json({ user: 'tobi' });
res.status(500).json({ error: 'message' });
</code></pre>
<h4>res.redirect([status,] path)</h4>
<p>重定向到指定的url,默认的http状态是302</p>
<pre><code class="language-javascript">res.redirect('/foo/bar');
res.redirect('http://example.com');
res.redirect(301, 'http://example.com');
res.redirect('../login');
</code></pre>
<h4>res.render(view [, locals] [, callback])</h4>
<p>渲染一个视图,并将html页面返回给客户端</p>
<ul>
    <li>
        <p>view</p>
        <p>指定一个视图,一般是html页面路径</p>
    </li>
    <li>
        <p>locals</p>
        <p>指定一个对象,里面包含了需要渲染到html中的数据</p>
    </li>
    <li>
        <p>callback</p>
        <p>回调函数</p>
    </li>
</ul>
<pre><code class="language-javascript">// send the rendered view to the client
res.render('index');

// if a callback is specified, the rendered HTML string has to be sent explicitly
res.render('index', function(err, html) {
  res.send(html);
});

// pass a local variable to the view
res.render('user', { name: 'Tobi' }, function(err, html) {
  // ...
});
</code></pre>
<h4>res.send([body])</h4>
<p>发送一个http response</p>
<ul>
    <li>
        <p>body</p>
        <p>该参数可以是一个Buffer object,object,String或者是Array</p>
        <pre><code class="language-javascript">res.send(new Buffer('whoop'));
res.send({ some: 'json' });
res.send('&lt;p&gt;some html&lt;/p&gt;');
res.status(404).send('Sorry, we cannot find that!');
res.status(500).send({ error: 'something blew up' });
</code></pre>
    </li>
</ul>
<h4>res.sendFile(path [, options] [, fn])</h4>
<p>根据指定的path来返回对应的文件, path必须是绝对路径</p>
<p>option参数</p>
<ul>
    <li>
        <p>headers</p>
        <p>指定文件对应的http的消息头</p>
    </li>
    <li>
        <p>root</p>
        <p>指定资源文件的根路径,如果没有该参数,则path必须要为绝对路径</p>
    </li>
    <li>
        <p>fn</p>
        <p>在文件传输结束或报错的时候的回调</p>
        <p>如果指定了回调函数,则在文件传输错误时必须要关闭这个response生命周期</p>
    </li>
</ul>
<pre><code class="language-javascript">app.get('/file/:name', function (req, res, next) {
  var options = {
    root: __dirname + '/public/',
    dotfiles: 'deny',
    headers: {
        'x-timestamp': Date.now(),
        'x-sent': true
    }
  };

  var fileName = req.params.name;
  res.sendFile(fileName, options, function (err) {
    if (err) {
      next(err);
    } else {
      console.log('Sent:', fileName);
    }
  });
});
</code></pre>
<p>该函数还支持更细粒度化的操作</p>
<pre><code class="language-javascript">// 根据不同用户的id和fileName来发送对应的文件
app.get('/user/:uid/photos/:file', function(req, res){
  var uid = req.params.uid
    , file = req.params.file;

  req.user.mayViewFilesFrom(uid, function(yes){
    if (yes) {
      res.sendFile('/uploads/' + uid + '/' + file);
    } else {
      res.status(403).send(&quot;Sorry! You can't see that.&quot;);
    }
  });
});
</code></pre>
<h4>res.sendStatus(statusCode)</h4>
<p>直接发送一个http状态码以直接结束请求</p>
<pre><code class="language-javascript">res.sendStatus(200); // equivalent to res.status(200).send('OK')
res.sendStatus(403); // equivalent to res.status(403).send('Forbidden')
res.sendStatus(404); // equivalent to res.status(404).send('Not Found')
res.sendStatus(500); // equivalent to res.status(500).send('Internal Server Error')
</code></pre>
<h4>res.set(field [, value])</h4>
<p>设置response响应的header信息</p>
<pre><code class="language-javascript">res.set('Content-Type', 'text/plain');

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  'ETag': '12345'
});
</code></pre>
<h4>res.status(code)</h4>
<p>设置http响应的状态码,并可以进行下一步操作</p>
<pre><code class="language-javascript">res.status(403).end();
res.status(400).send('Bad Request');
res.status(404).sendFile('/absolute/path/to/404.png');
</code></pre>
<h1>模板渲染</h1>
<p><code>app.engine(ext, callback)</code></p>
<p>使用该方法可以创建一个模板渲染引擎</p>
<pre><code class="language-javascript">var fs = require('fs') // this engine requires the fs module
app.engine('ntl', function (filePath, options, callback) { // 定义template engine
  fs.readFile(filePath, function (err, content) {
    if (err) return callback(err)
    // this is an extremely simple template engine
    var rendered = content.toString().replace('#title#', '&lt;title&gt;' + options.title + '&lt;/title&gt;')
    .replace('#message#', '&lt;h1&gt;' + options.message + '&lt;/h1&gt;')
    return callback(null, rendered)
  })
})
app.set('views', './views') // 指定要渲染的视图的目录
app.set('view engine', 'ntl') // 注册 template engine
</code></pre>
<p>使用模板引擎进行渲染</p>
<pre><code class="language-javascript">app.get('/', function (req, res) {
  res.render('index', { title: 'Hey', message: 'Hello there!' })
})
</code></pre>
<h1>相关模块</h1>
<h2>express-session模块</h2>
<p>这是一个session模块,可以快速的将session添加到express框架中</p>
<p>使用</p>
<ul>
    <li>
        <p>安装</p>
        <p><code>cnpm i express-session -S</code></p>
    </li>
    <li>
        <p>创建</p>
        <pre><code class="language-js">var session = require(&quot;express-session&quot;);
app.use(
  session({
    secret: &quot;this is a string key&quot;, //加密的字符串，里面内容可以随便写
    resave: false, //强制保存session,即使它没变化
    saveUninitialized: true //强制将未初始化的session存储，默认为true
  })
);
</code></pre>
    </li>
    <li>
        <p>使用</p>
        <pre><code class="language-js">req.session.isLogin=true; //创建session
console.log(req.session.isLogin); //获取session
</code></pre>
    </li>
</ul>
<h1>参考文档</h1>
<p><a href="https://www.runoob.com/nodejs/nodejs-express-framework.html">express教程</a></p>
<p><a href="http://www.expressjs.com.cn/">express官方文档</a></p>








</body>
</html>